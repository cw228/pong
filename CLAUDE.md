# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Tool Usage

**Context7 MCP:** Always use Context7 (`resolve-library-id` then `query-docs`) to look up library/API documentation when answering questions about APIs, generating code that uses external libraries, or providing setup/configuration steps. Do not rely solely on training data for library-specific details.

## Build Commands

```bash
cmake -B build -G Ninja                    # Configure (debug by default)
cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=Release  # Configure release
cmake --build build                        # Build
./build/pong                               # Run
```

The project requires `CMAKE_CXX_COMPILER` to be set to clang++ (usually via environment variable).

**macOS with Homebrew LLVM:** When using Ninja, you must pass `CMAKE_OSX_SYSROOT` explicitly on the command line (environment variable alone doesn't work due to `clang-scan-deps` not receiving it):
```bash
cmake -B build -G Ninja -DCMAKE_OSX_SYSROOT=$(xcrun --show-sdk-path)
```

## Architecture

Vulkan application split across:
- **`src/main.cpp`** — constructs `Window` and `Renderer`, runs the main loop; `Renderer` destructor handles `waitIdle()` implicitly
- **`src/renderer.cpp`** / **`src/renderer.h`** — `Renderer` class encapsulates all Vulkan setup; takes `Window&` (borrows, does not own); destructor calls `device.waitIdle()` before RAII members are destroyed
- **`src/window.h`** — `Window` struct wrapping `GLFWwindow*`; constructor takes `(int width, int height)` and owns GLFW init + window creation; destructor calls `glfwDestroyWindow` + `glfwTerminate`
- **`src/gamestate.h`** / **`src/gamestate.cpp`** — `GameState`, `Entity`, `Instance`, `Level`, `Model`, `Texture` structs; `loadGameState(path)` parses `Pong.json` (generated by `pong.py`)
- **`pong.py`** / **`tools/game_data.py`** / **`tools/utility.py`** — Python level builder; run via CMake (`gamedata` target) to produce `Pong.json`; uses module-level singleton `_DATA` and `asdict` for JSON serialization

Uses **C++23** with designated initializers for Vulkan structs, **Vulkan-Hpp RAII wrappers** (`vk::raii::*`), and **GLFW** for windowing.

**Destruction order:** Declare `Window window` before `Renderer renderer` so that `renderer` is destroyed first (reverse construction order). Safe because `Renderer` holds `Window&` — the referent must outlive the reference holder. `Renderer::~Renderer()` calls `device.waitIdle()` before any RAII members are destroyed — the destructor body runs before member destructors, so the device is always idle before cleanup.

**`Window` is outside the try block in `main.cpp`** intentionally: GLFW calls don't throw C++ exceptions (they return error codes), and `Window` must outlive `Renderer` which may throw during construction. Both locals would still be destroyed in the right order inside a try block, but keeping `Window` outside makes the lifetime relationship explicit.

**`Renderer` constructor flow:** Takes `Window&`, calls `glfwSetWindowUserPointer` + `glfwSetFramebufferSizeCallback`, then `createRenderState()` (loads models, builds `RenderState` from `GameState`), then `initVulkan()`:
`createInstance()` → `setupDebugMessenger()` → `createSurface()` → `pickPhysicalDevice()` → `findQueueFamilies()` → `createLogicalDevice()` → `getQueues()` → `createSwapchain()` → `createSwapchainImageViews()` → `createDescriptorSetLayout()` → `createGraphicsPipeline()` → `createCommandPool()` → `createColorResources()` → `createDepthResources()` → `createTextureImage()` → `createTextureImageView()` → `createTextureSampler()` → `loadModel()` → `createVertexBuffer()` → `createIndexBuffer()` → `createUniformBuffers()` → `createDescriptorPool()` → `createDescriptorSets()` → `createCommandBuffers()` → `createSyncObjects()`

## Game Data / Level Builder

`pong.py` imports `tools.game_data` and constructs `Entity`, `Instance`, `Level`, `Model`, `Texture` objects (each auto-registers into a module-level `_DATA` singleton). `export("Pong.json")` serializes via `dataclasses.asdict`. CMake runs `pong.py` automatically via the `gamedata` custom target (depends on `pong.py` and `tools/game_data.py`); `pong` executable depends on `gamedata`.

**JSON structure:** `{ "entities": {}, "levels": {}, "models": {}, "textures": {} }`. Integer dict keys are serialized as strings by Python's `json` module. `entity_instances` is nested: `level → entity_id → instance_id → instance fields`.

**`loadGameState` JSON parsing:** When iterating nested `.items()` loops, be careful to read fields from the innermost loop variable, not an outer one. Reading `val` (the level object) instead of `instance` (the instance object) in the inner loop silently gives wrong values or throws `json::out_of_range`.

## Shaders

Shaders are written in **Slang** (`shaders/shader.slang`) and compiled to SPIR-V by CMake using `slangc` from the Vulkan SDK. Output goes to `build/shaders/`.

## Synchronization (Frames in Flight)

Uses `MAX_FRAMES_IN_FLIGHT = 2` with the following sync objects:

| Resource | Count | Indexed by | Protected by |
|----------|-------|------------|--------------|
| `presentCompleteSemaphores` | 2 (frames) | `frameIndex` | fence wait |
| `renderFinishedSemaphores` | N (images) | `imageIndex` | image re-acquisition |
| `commandBuffers` | 2 (frames) | `frameIndex` | fence wait |
| `drawFences` | 2 (frames) | `frameIndex` | (the protection itself) |

**Why the difference?** Fences tell us GPU work is done, but `presentKHR` runs asynchronously after that. The only guarantee that an image's presentation is complete is when `acquireNextImage` returns that same image again. So `renderFinishedSemaphores` must be tied to image index, not frame index.

**Semaphore reuse rules:** Binary semaphores must be used in strict signal/wait pairs. A semaphore can only be reused after both operations complete. The fence tells us `submit()` finished (so `presentCompleteSemaphore`'s wait completed → safe to reuse). But for `renderFinishedSemaphore`, the wait is in `presentKHR` which has no fence — we rely on `acquireNextImage` returning the same image to know that present completed.

**Input latency:** More frames in flight = more latency between input and display. With 2 frames in flight at 60Hz, expect ~50ms pipeline latency. This is why competitive games minimize frames in flight.

**Synchronization primitives summary:**

| Primitive | Synchronizes between |
|-----------|---------------------|
| Pipeline barrier | Commands within the same queue (not just within a single command buffer) |
| Semaphore | Queue submissions / queue operations (e.g., acquire → submit → present) |
| Fence | GPU and CPU |

**Access flags — prefer narrow over broad:** Use `eShaderSampledRead` instead of `eShaderRead` when the image is only used as a sampled texture. `eShaderRead` is a catch-all covering sampled reads, storage reads, and binding table reads — overly broad flags may cause unnecessary cache flushes.

**Init-time GPU uploads:** `device.waitIdle()` in `endSingleTimeCommands()` is fine for init-time staging uploads (textures, vertex/index buffers). For runtime uploads, replace with a fence on the specific submit.

**Barrier source/destination masks:** A barrier has four synchronization components:
- Source stage: what must finish *executing*
- Source access: what writes must be *flushed from cache* (availability — data leaves the writer's private cache into shared memory)
- Dest stage: what must *wait* before executing
- Dest access: what caches must be *invalidated* so reads see the flushed data (visibility — reader's stale cache entries are discarded)

Availability (flush) is the expensive part and only needs to happen once. Visibility (invalidation) is cheap and done per-consumer. Access flags map to hardware caches (e.g., `eColorAttachmentWrite` → ROP cache, `eShaderSampledRead` → texture unit cache), not to pipeline stages — that's why you specify both stage and access type.

**Image layout transitions and content preservation:** Any source layout other than `eUndefined` implicitly means "preserve the contents" — the driver uses the source layout to know how the data is currently arranged so it can convert it. `eUndefined` means "I'm not telling you the current layout," so the driver *can't* preserve the data and may discard it. Specifying the wrong source layout (not matching the image's actual current layout) is undefined behavior — the driver trusts you, and validation layers track this.

**Depth image uses a single buffer** (not one per frame in flight) because the pipeline barrier before each frame's depth writes synchronizes against prior depth writes on the same queue. This serializes the depth-related work between frames while allowing other stages (vertex processing, color writes) to overlap. Combined with `eUndefined` source layout + `loadOp::eClear` + `storeOp::eDontCare`, the depth buffer is purely transient within each frame.

**Image initial layouts:** Images are created with `initialLayout` which can only be `eUndefined` or `ePrelinear`. Almost always use `eUndefined` — `ePrelinear` is only for CPU-mapped linearly-tiled images. The first layout transition for most images will therefore have `eUndefined` as the source.

**Semaphores carry implicit memory dependencies:** A semaphore signal makes all available memory visible after the corresponding wait. This is why the present-transition barrier can have empty destination access/stage — the barrier flushes color writes (availability), and the `renderFinishedSemaphore` between submit and `presentKHR` handles visibility to the presentation engine. Chain: barrier flushes → semaphore signal picks up available data → semaphore wait makes it visible.

## Wayland/Hyprland Notes

- Window won't appear until content is rendered (unlike X11)
- `GLFW_RESIZABLE = FALSE` causes issues on tiling compositors - avoid it
- Swapchain doesn't report `eErrorOutOfDateKHR` on resize - compositor scales the output instead. Must manually detect size changes via `glfwGetFramebufferSize()` or framebuffer callback

## Key Configuration

- `VULKAN_HPP_NO_STRUCT_CONSTRUCTORS` - Enables C++20 designated initializers for Vulkan structs
- `GLFW_INCLUDE_VULKAN` - GLFW includes Vulkan headers
- Validation layers enabled in debug builds (`#ifndef NDEBUG`)
- Precompiled headers for `vulkan_raii.hpp` and `GLFW/glfw3.h` to reduce compile times
- `VK_KHR_portability_subset` device extension required on macOS (MoltenVK)
- MoltenVK is Vulkan 1.2, so Vulkan 1.3 features need their extensions explicitly enabled on macOS (e.g., `VK_KHR_synchronization2`, `VK_KHR_dynamic_rendering`)

## C++ Conventions

**Parameter passing:**
- Vulkan handles (`vk::Image`, `vk::Buffer`) — pass by value (they're just 64-bit integers)
- RAII wrappers (`vk::raii::Image`, `vk::raii::CommandBuffer`) — pass by reference (non-copyable)
- Large structs, `std::string`, `std::vector` — pass by `const T&`

**Swapchain images:** `swapchain.getImages()` returns `vk::Image` (not `vk::raii::Image`) because the swapchain owns these images. You don't destroy them — the swapchain does when it's destroyed.

**Return values:** Returning RAII objects by value is idiomatic. The compiler uses move semantics or copy elision (constructs directly in caller's stack frame). No explicit `std::move` needed on return.

**RAII wrapper initialization:** Use `= nullptr` for empty handles to be assigned later (clearer than `({})`). RAII wrappers implicitly convert to bare handles, or use `*wrapper` to explicitly extract the handle.

**RAII wrappers and containers:** RAII wrappers are non-copyable. When adding to a `std::vector`, either use `std::move(obj)` with `push_back`, or pass the factory function return value directly (it's already an rvalue): `vec.push_back(createThing(...))`.

**Vulkan-Hpp struct pointer semantics:** Structs like `vk::DependencyInfo`, `vk::RenderingInfo`, etc. store raw pointers (`pImageMemoryBarriers`, etc.), not copies. Mutating the pointed-to data and resubmitting the parent struct works without recreating it — useful for reusing a barrier in a loop (e.g., mipmap generation).

**Descriptor pool sizing:** `maxSets` and `pPoolSizes` are independent limits — `maxSets` caps total descriptor sets allocated, `pPoolSizes` caps total descriptors per type. Both must be satisfied for allocation to succeed.

**`std::unordered_map::operator[]`** default-constructs the value if the key is absent, so an explicit `contains()` check before insertion is always redundant.

## Multisampling (MSAA)

**Depth must be multisampled at the same rate as color.** Each color sample needs its own depth value for an independent depth test. With single-sampled depth, the depth test is per-pixel (pass/fail for all samples), so draw order affects correctness — a closer triangle drawn first would cause a farther triangle to be entirely discarded, leaving uncovered samples as background instead of showing the farther triangle. Per-sample depth eliminates draw-order dependence.

**`getMaxUsableSampleCount`:** `vk::SampleCountFlags` is a bitmask where bit N = 2^N samples. Casting to `uint32_t` and using `std::bit_floor` (C++20, `<bit>`) finds the highest supported power-of-2 sample count. Intersect `framebufferColorSampleCounts & framebufferDepthSampleCounts` to ensure both attachments support the chosen count.

**Depth resolve:** MSAA resolve only operates on color — it averages color samples into the single-sample framebuffer. Per-sample depth values are discarded (hence `storeOp::eDontCare` on the depth attachment). Averaging depth values would be meaningless.

**Dynamic rendering MSAA resolve:** With dynamic rendering, resolve is configured inline on the primary (MSAA) color attachment via `resolveMode`, `resolveImageView`, and `resolveImageLayout` — not by adding a second color attachment. (With legacy `VkRenderPass`, resolve was a separate `pResolveAttachments` array in the subpass.) The `loadOp`/`storeOp` on the attachment apply only to the MSAA image; the resolved result is always stored to `resolveImageView` implicitly. Use `storeOp::eDontCare` on the MSAA image since its contents aren't needed after resolve.

**MSAA color image is transient** (like depth): uses `eUndefined` source layout + `loadOp::eClear` + `storeOp::eDontCare`. Needs its own layout transition to `eColorAttachmentOptimal` before rendering.

**Resolve synchronization:** The resolve operation uses `eColorAttachmentOutput` stage and `eColorAttachmentWrite` access — same as regular color writes. There is no separate resolve stage in Vulkan's synchronization model.

## Shader Notes

**MVP matrix order:** In Slang/HLSL, transformations apply right-to-left. Use `mul(projection, mul(view, mul(model, position)))` to get the correct `projection * view * model * position` order.

**GLM model matrix (TRS):** Build as scale → rotate → translate so the net matrix is T×R×S (scale applied first to vertices). In GLM each call left-multiplies, so call in reverse application order: `glm::scale(identity, ...)`, then `glm::rotate(...)`, then `glm::translate(...)`. Rotation is around the Z-axis for 2D; `rotation` field is in degrees, convert with `glm::radians()`.

**`SV_InstanceID` in Slang/SPIR-V:** When Slang compiles to SPIR-V for Vulkan, `SV_InstanceID` maps to `gl_InstanceIndex`, which **includes** the `firstInstance` offset passed to `drawIndexed`. This means it directly indexes into an SSBO of model matrices when `firstInstance` is set to each entity's base offset — no extra arithmetic needed in the shader.

**LOD (Level of Detail):** LOD 0 = mip level 0 = full-resolution base image. Higher LOD selects higher mip levels (smaller, less detailed). `minLod = 0.0f` and `maxLod = LodClampNone` allows the sampler to use the full mip range.

**Depth values:** The vertex shader outputs clip-space `z` via `SV_Position`. Fixed-function hardware then does perspective division (`z / w`) to get NDC depth [0, 1] (Vulkan range, unlike OpenGL's [-1, 1]), then the viewport transform maps it to framebuffer depth: `depth = minDepth + ndc.z * (maxDepth - minDepth)`. No shader code needed for depth — the projection matrix encodes the z mapping.

## Troubleshooting

**Stale precompiled header after system update:** If you see an error about a header being modified since the PCH was built, delete the PCH and rebuild:
```bash
rm -f build/CMakeFiles/pong.dir/cmake_pch.hxx.pch && cmake --build build
```

**GPU hang / system freeze:** If running the app freezes the system (black screen, blinking cursor), the GPU is hanging. Common cause: shader accesses a descriptor (UBO, texture) that was never bound. Always ensure descriptor sets are created, updated, and bound before draw calls that use them.

**`window.h` missing `#pragma once`:** If `window.h` is included from both `renderer.h` and `main.cpp`, you'll get a `redefinition of 'Window'` error. The fix is to add `#pragma once` at the top of `window.h`.

## Dependencies

- **stb_image** (`pacman -S stb`) — header-only image loading. Requires `#define STB_IMAGE_IMPLEMENTATION` before include in exactly one source file. `stbi_uc` is a typedef for `unsigned char`.
- **nlohmann_json** — JSON parsing for `Pong.json`. Use `.at()` (throws on missing key) rather than `[]` when parsing required fields.
